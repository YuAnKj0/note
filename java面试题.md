java 



### **jvm中的内存区域**

#### jvm中有五大内存区域，分别是程序计数器，java栈，本地方法栈，堆，方法区

1.程序计数器是线程私有的，如果是底层方法，那么计数器为空

2.java栈，也是虚拟机栈，描述的是方法执行的内存模型，每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息，每一个方法被调用的过程就是对应的一个栈帧在虚拟机中从入栈到出栈的过程。平常说的栈是存储局部变量表的部分，局部变量表所需要的内存空间在编译器内完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小，

Java虚拟机栈中可能出现两种类型的异常：

1）线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError

2)虚拟机占空间可以动态扩展，当动态扩展时无法申请到足够的空间时，抛出OutOfMemory异常

3.本地方法栈，

与虚拟机栈发挥的作用相似，区别时虚拟机栈执行的是Java方法，，也就是字节码，而本地方法栈使用到的native方法服务，可能底层调用的是c或者c++，jdk安装目录可以看到很多用c编写的文件，可能就是native方法调用的c代码

4.堆

堆是Java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制

所有对象实例及数组都要在对上分配内存，

堆是所有线程共享的，他的目的是存放对象实例，同时它也是GC所管理的主要区域，因此常被称为GC堆，又因为现在收集器常用分代算法，Java堆中还可以细分为新生代和老生代，

根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要是连续的即可，他的内存大小可以设定为固定大小，也可以扩展，当前主流的虚拟机如HotPot都能扩展实现（通过设置-Xmx和-Xms），如果堆中没有内存完成实例的分配，而且对无法扩展将报OOM错误（OutOfMemaryError）

5.方法区，

方法区同堆一样，是所有线程共享的区域，方法区用于存储已被虚拟机加载的类信息，常量，静态变量等。



### **垃圾回收与算法**

1.触发条件:程序调用System.gc时可以触发，系统自身来决定GC 触发的时机

#### 2.如何回收：

1）标记-清除算法，

标记：垃圾收集器会将所有堆中的对象都扫描一遍，将需要回收的对象所在的内存和不需要回收对象所在的内存作标记，以此确定回收的对象，

清楚：垃圾收集器会清除掉上一步标记出来的那些需要回收的对象区域

问题：标记清楚后会产生大量的不连续内存碎片，碎片太多会导致以后在程序运行过程中需要分配较大的对象时，无法找到连续的足够内存而不得不提前触发另一次垃圾收集动作



2）复制算法

复制算法将内存按容量大小划分为相等的两块，每次只是用其中的一块，当这一块使用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉，这样使得每次都是对半区域的内存回收，内存分配时就不用考虑到内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，内存高效，缺点就是会减少可使用内存



3）标记整理算法

由于简单的标记清楚会存在碎片问题，所以出现了压缩清楚的算法，就是先清除需要回收的对象，然后再对内存进行压缩操作，将内存分成可用和不可用两部分

4）分代收集算法，

是上面算法的综合，Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的算法，在新生代中，每次收集时都会有大量的对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，而老年代因为对象存活率较高，没有额外的空间对他进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来回收

垃圾收集器分为串行收集器，并行收集器，并发收集器

Serial(用于新生代，采用复制算法，)（串行收集器）

Serial(用于老年代，采用标记整理算法)（串行收集器）

Parnew(用于新生代，采用复制算法)（并行收集器）

Parallel old(用于老年代，采用标记整理算法)（并行收集器）

Parallel Scavenge(用于新生代，采用复制算法)（并行收集器）

CMS(用于老年代，采用标记清除算法)（并发收集器）

Gl(jdk7以后的版本推出，维持高回收率，减少停顿，Java9 默认GC算法是Gl,且把CMS标记为废弃)

JVM分为两种模式

client模式和server模式，默认是client模式，server模式启动较慢，但长时间运行的话，运行会越来越快

Java的垃圾回收某个对象的时候，都要依据引用的概念

在不同的垃圾回收算法中，对引用的判断方式有所不同：

引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收（目前Java中已经弃用这种方式了）

可达性分析算法：从一个被称为 GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用





jvm运行时内存有哪些

### **四种引用类型**

#### 强引用(Strong Reference):Java中默认声明 的引用

```java
Object obj=new Object();//只要obj还是指向Object对象，Object对象就不会被回收
obj=null;//手动置空
```

只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足，jvm会直接抛出OutOfMemoryError异常，不会去回收，如果想中断强引用与对象之间的联系，可以显示的将对象赋值为null，这样一来，jvm可以适时的回收对象了。

软引用(Soft Refrence) ：用来描述一些非必须但有用的对象，在内存足够的时候，软引用对象不会被回收，只有内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性通常用来实现缓存技术，如网页缓存，图片缓存等，用SoftRefrence类表示软引用。

```java
 private static void testSoftReference() {
        for (int i = 0; i < 10; i++) {
            byte[] buff=new byte[1024*1024];
            SoftReference<byte[]> sr=new SoftReference<>(buff);
            list.add(sr);
        }
        System.gc();//主动通知垃圾回收
        for (int i = 0; i < list.size(); i++) {
            Object obj=((SoftReference)list.get(i)).get();
            System.out.println(obj);
        }
    }
```

弱引用(WeakRefrence)：引用强度比软引用更弱一些，无论内存是否足够，只要jvm进行垃圾回收，那些被弱引用关联的对象都会被回收，用WeakReference表示弱引用

虚引用(PhantomRefrence) ：最弱的引用关系，如果一个对象仅持有弱引用，那么他跟没有引用一样，随时可能会被回收，用PhantomReference类表示。在源码中，这个类只有一个构造方法和一个ge()方法，而他的get()方法只返回一个null，也就是说无法通过虚引用来获取对象，所以与软引用、弱引用不同，虚引用必须要和ReferenceQueue引用队列一起使用

引用队列(RefrenceQueue)：引用队列可以与软引用、弱引用和虚引用一起使用，当垃圾回收器回收一个对象时，如果发现他还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去，程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在被回收之前采取一些必要的措施。



### **IO和NIO的区别**

NIO即New IO，NIO和IO有相同的作用和目的，但是实现方式不同，NIO主要用到的是块，所以NIO的效率比IO高很多，在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO

| IO     | NIO      |
| ------ | -------- |
| 面向流 | 面向缓冲 |
| 阻塞IO | 非阻塞IO |
| 无     | 选择器   |

1.面向流与面向缓冲

Java IO与NIO最大的区别是面向流与面向缓冲，IO面向流意味着每次从流中读取一个或多个字节，直至读取所有字节，他们没有被缓存存在任何地方，此外他不能前后移动流中的数据，如果需要前后移动从流中读取的数据，需要将他缓存在缓存区，NIO的缓冲导向方法略有不同，数据读取到一个他稍后处理的缓冲区，需要时可在缓冲区中前后移动，增加了数据处理的灵活性，但是还需要检查是否该缓冲区中包含所有需要处理的数据，而且需确保当更多的数据读入到缓冲区时，不要覆盖缓冲区未处理的数据。

2.阻塞与非阻塞IO

Java IO的各种流是阻塞的，这意味着当一个线程调用read()或者write()时，该线程被阻塞，知道有一些数据被读取，或数据完全写入，该线程在此期间不能在干任何事了，Java NIO是非阻塞模式，使一个线程在某通道发送请求读取数据，但是他仅能得到目前可用的数据，如果目前没有可用数据时，就什么都不会读取，而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情，非阻塞写也是如此，一个线程请求写入数据到某通道，但不需要等待他完全写入，这个线程同时可以去做其他的事情，线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道(channal)

3.选择器(Selcetors)

Java NIO的选择器允许一个单独的线程监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程选择通道，这些通道里已经有可以处理的输入，或者选择已准备写入的通道，这种选择机制，可以使一个单独的线程管理多个通道



### java的类加载机制

1.jvm将类的加载过程分三个步骤：装载(Load)、链接(Link)、初始化(Initialize)，链接又分为三个步骤：

1）装载：查找并加载类的二进制数据

2）链接：

​				验证：确保被加载类的正确性

​				准备：为类的静态变量分配内存，并将其初始化为默认值

​				解析：把类的符号引用转换为直接引用

3）初始化：为类的静态变量赋予正确的初始值

2.类的初始化：

类什么时候被初始化：

 1）创建类的实例，即new一个对象

2）访问某个类或者接口的静态变量，或者对该静态变量进行赋值

3）调用类的静态方法

4）反射(Class.forName(“com.y.load”))

5）初始化一个子类（会首先初始化一个子类的父类）

6）jvm启动时标明的启动类，即文件名和类名相同的那个类

3.类的初始化步骤：

1） 如果这个类没有被加载或者链接，那先进行加载和链接

2）假如这个类存在直接父类，并且这个二类还没有初始化（在类加载器中，一个类只能被初始化一次），那就初始化直接的父类（不适用于接口）

3）假如类中存在初始化语句（如static变量或者static块）那就依次执行这些初始化语句

4.类的加载

类的加载指的是将类的.class文件中二进制数据读入内存中，将其放在运行时数据区的方法内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象：

![img](https://images2018.cnblogs.com/blog/991670/201806/991670-20180628155146481-1545095755.png)



![img](https://images2018.cnblogs.com/blog/991670/201806/991670-20180628155204199-1045249479.png)

类加载的最终产品是位于堆区的Class对象，Class对象封装了类在方法区内的数据结构，并且向程序员提供了访问方法区内数据结构的接口

加载类的方式有一下几种：

1）通过本地系统直接加载

2）通过网络下载.class文件

3）从zip，jar等归档文件中加载.class文件

4）从专有数据库中提取.class文件

5）将Java源文件动态编译为.class文件

JVM的类的加载是通过CLassLoader及其子类完成的，

1）BootStrap ClassLoader：负责加载%JAVA_HOME%中jre/lib/rt.jar里所有的class，由C#实现，不是ClassLoader子类

2）Extension ClassLoader：负责加载Java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/ext/*.jar或者-Djava.ext.dirs指定目录下的包

3）App ClassLoader：负责加载classpath中指定的jar包及目录中的class

4）Custom ClassLoader：如tomcat，jboss都会根据j2ee规范自行实现ClassLoader，加载过程中会先检查类是否已经被加载，检查顺序自底向上，从Custom ClassLoader到Bootstrap ClassLoader逐层检查，只要某个class Loader已加载就视为已加载此类，保证此类在所有Class Loader只加载一次，而加载的顺序写是自顶向下，也就是由上层来逐层尝试加载此类











### 双亲委派机制



### tomcat如何打破了双亲委派机制



### 集合



### listde 底层实现



### set的底层时如何实现的



### Map当中的CurrentHashMap是如何实现线程安全的



### 创建线程的四种方式



### 四种线程池分别是什么，线程的生命周期是什么，如何终止线程，sleep和wait的区别，start和run的区别，



### Java当中的锁机制有哪些，synchronize的作用核心和实现是什么



### 线程当中有什么方法，上下文如何切换，



### CAS AQS



### 异常有哪些，怎么分类的，





### 反射的好处是什么



### 注解，内部类，泛型，序列化



### cookie和session分别是干什么的，转发和重定向的区别，



### jsp 的四种作用域和九种内置对象，



### spring的特点，核心组件有哪些，常用注解



### ioc的原理



### springbean的作用周期，作用域



### spring aop又是什么



### spring MVC的工作流程



### springboot 的原理



### mybatis有几个缓存区



### 微服务的组件：网关，注册中心，事件调度跟踪熔断分别是哪些组件



### netty和rpc有什么联系



### 网络的七层架构和五层架构



### tcp/ip的原理



### tcp为什么需要三次握手



### http的原理和状态



### 日志框架 log4j



### zookeeper有那些角色，投票机制什么



### 消息队列 



### rabbit MQ的几种工作模式，怎么保证消息的可靠性，怎么保证消息不被重复消费，消息的有序性，



### kafka的设计理念



### 数据量过大数据库存不下，hbase的核心概念是什么，有哪些核心的架构，写逻辑



### mangoDB 适合在什么场景下使用



### 设计模式：



### 负载均衡做过哪些，有哪些策略与算法



### lvs,keep live还有nginx的负载均衡有什么区别



### 索引是怎么构建的，如何失效，三范式是什么，数据库事务，存储过程，触发器，



### 慢sql怎么定位，怎么解决，多少量级的数据可以考虑分库分表，依据是什么



### 一致性算法：paxos算法，



### 算法:冒泡，二分，



### 最短路径算法如何算的



### 数据结构有哪些



### 排序二叉树，红黑树，



### 加密算法，rsa



### 分布式缓存中缓存如何雪崩，缓存穿透如何解决，缓存预热是什么，缓存如何更新，如何降级，







