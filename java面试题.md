java 



**jvm中的内存区域**

jvm中有五大内存区域，分别是程序计数器，java栈，本地方法栈，堆，方法区

1.程序计数器是线程私有的，如果是底层方法，那么计数器为空

2.java栈，也是虚拟机栈，描述的是方法执行的内存模型，每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息，每一个方法被调用的过程就是对应的一个栈帧在虚拟机中从入栈到出栈的过程。平常说的栈是存储局部变量表的部分，局部变量表所需要的内存空间在编译器内完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表大小，

Java虚拟机栈中可能出现两种类型的异常：

1）线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError

2)虚拟机占空间可以动态扩展，当动态扩展时无法申请到足够的空间时，抛出OutOfMemory异常

3.本地方法栈，

与虚拟机栈发挥的作用相似，区别时虚拟机栈执行的是Java方法，，也就是字节码，而本地方法栈使用到的native方法服务，可能底层调用的是c或者c++，jdk安装目录可以看到很多用c编写的文件，可能就是native方法调用的c代码

4.堆

堆是Java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制

所有对象实例及数组都要在对上分配内存，

堆是所有线程共享的，他的目的是存放对象实例，同时它也是GC所管理的主要区域，因此常被称为GC堆，又因为现在收集器常用分代算法，Java堆中还可以细分为新生代和老生代，

根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要是连续的即可，他的内存大小可以设定为固定大小，也可以扩展，当前主流的虚拟机如HotPot都能扩展实现（通过设置-Xmx和-Xms），如果堆中没有内存完成实例的分配，而且对无法扩展将报OOM错误（OutOfMemaryError）

5.方法区，

方法区同堆一样，是所有线程共享的区域，方法区用于存储已被虚拟机加载的类信息，常量，静态变量等。



垃圾回收与算法

1.触发条件:程序调用System.gc时可以触发，系统自身来决定GC 触发的时机

2.如何回收：

1）标记-清除算法，

标记：垃圾收集器会将所有堆中的对象都扫描一遍，将需要回收的对象所在的内存和不需要回收对象所在的内存作标记，以此确定回收的对象，

清楚：垃圾收集器会清除掉上一步标记出来的那些需要回收的对象区域

问题：标记清楚后会产生大量的不连续内存碎片，碎片太多会导致以后在程序运行过程中需要分配较大的对象时，无法找到连续的足够内存而不得不提前触发另一次垃圾收集动作



2）复制算法

复制算法将内存按容量大小划分为相等的两块，每次只是用其中的一块，当这一块使用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉，这样使得每次都是对半区域的内存回收，内存分配时就不用考虑到内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，内存高效，缺点就是会减少可使用内存



3）标记整理算法

由于简单的标记清楚会存在碎片问题，所以出现了压缩清楚的算法，就是先清除需要回收的对象，然后再对内存进行压缩操作，将内存分成可用和不可用两部分

4）分代收集算法，

是上面算法的综合，Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的算法，在新生代中，每次收集时都会有大量的对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，而老年代因为对象存活率较高，没有额外的空间对他进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来回收

垃圾收集器分为串行收集器，并行收集器，并发收集器

Serial(用于新生代，采用复制算法，)（串行收集器）

Serial(用于老年代，采用标记整理算法)（串行收集器）

Parnew(用于新生代，采用复制算法)（并行收集器）

Parallel old(用于老年代，采用标记整理算法)（并行收集器）

Parallel Scavenge(用于新生代，采用复制算法)（并行收集器）

CMS(用于老年代，采用标记清除算法)（并发收集器）

Gl(jdk7以后的版本推出，维持高回收率，减少停顿，Java9 默认GC算法是Gl,且把CMS标记为废弃)

JVM分为两种模式

client模式和server模式，默认是client模式，server模式启动较慢，但长时间运行的话，运行会越来越快



jvm运行时内存有哪些

四种引用类型







































GC垃圾回收器有哪些

IO和NIO的区别

java的类加载机制

双亲委派机制

tomcat如何打破了双亲委派机制

集合

listde 底层实现

set的底层时如何实现的

Map当中的CurrentHashMap是如何实现线程安全的

创建线程的四种方式

四种线程池分别是什么，线程的生命周期是什么，如何终止线程，sleep和wait的区别，start和run的区别，

Java当中的锁机制有哪些，synchronize的作用核心和实现是什么

线程当中有什么方法，上下文如何切换，

CAS AQS

异常有哪些，怎么分类的，

反射的好处是什么

注解，内部类，泛型，序列化

cookie和session分别是干什么的，转发和重定向的区别，

jsp 的四种作用域和九种内置对象，

spring的特点，核心组件有哪些，常用注解

ioc的原理

springbean的作用周期，作用域，

spring aop又是什么

spring 吗VC的工作流程

springboot de 原理

mybatis有几个缓存区

微服务的组件：网关，注册中心，事件调度跟踪熔断分别是哪些组件

netty和rpc有什么联系

网络的七层架构和五层架构

tcp/ip的原理

tcp为什么需要三次握手

http的原理和状态

日志框架 log4j

zookeeper有那些角色，投票机制什么

消息队列 

rabbit MQ的几种工作模式，怎么保证消息的可靠性，怎么保证消息不被重复消费，消息的有序性，

kafka的设计理念

数据量过大数据库存不下，hbase的核心概念是什么，有哪些核心的架构，写逻辑

mangoDB 适合在什么场景下使用

设计模式：

负载均衡做过哪些，有哪些策略与算法

lvs,keep live还有nginx的负载均衡有什么区别

索引是怎么构建的，如何失效，三范式是什么，数据库事务，存储过程，触发器，

慢sql怎么定位，怎么解决，多少量级的数据可以考虑分库分表，依据是什么

一致性算法：paxos算法，

算法:冒泡，二分，

最短路径算法如何算的

数据结构有哪些

排序二叉树，红黑树，

加密算法，rsa

分布式缓存中缓存如何雪崩，缓存穿透如何解决，缓存预热是什么，缓存如何更新，如何降级，







